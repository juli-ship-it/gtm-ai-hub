import { Client } from '@modelcontextprotocol/sdk/client/index.js'
import { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js'
import { spawn } from 'child_process'

export interface CrayonMCPConfig {
  apiKey: string
  accountId: string
  workspaceId: string
  readOnly?: boolean
  maxResults?: number
  timeout?: number
  auditLogging?: boolean
}

export interface CrayonQueryOptions {
  timeRange?: string
  include?: string[]
  limit?: number
  offset?: number
  product?: string
  useCase?: string
  market?: string
  competitor?: string
  prospect?: string
  dealStage?: string
  alertTypes?: string[]
  categories?: string[]
}

export interface CrayonBattlecard {
  competitor: string
  strengths: string[]
  weaknesses: string[]
  positioning: string
  objections: string[]
  responses: string[]
  lastUpdated: string
}

export interface CrayonWinLossStory {
  id: string
  competitor: string
  outcome: 'won' | 'lost'
  dealValue: number
  keyFactors: string[]
  lessons: string[]
  date: string
}

export interface CrayonCompetitorProfile {
  name: string
  description: string
  products: string[]
  pricing: {
    model: string
    range: string
    notes: string
  }
  recentNews: string[]
  marketPosition: string
  lastUpdated: string
}

export interface CrayonObjectionHandling {
  objection: string
  competitor: string
  context: string
  response: string
  supportingData: string[]
  successRate: number
}

export interface CrayonDealIntelligence {
  prospect: string
  competitors: string[]
  dealStage: string
  competitiveThreats: string[]
  opportunities: string[]
  recommendations: string[]
  lastUpdated: string
}

export interface CrayonMarketAlert {
  id: string
  type: string
  competitor: string
  title: string
  description: string
  impact: 'high' | 'medium' | 'low'
  date: string
}

export class CrayonMCPClient {
  private client!: Client
  private config!: CrayonMCPConfig
  private isConnected: boolean = false

  constructor(config: CrayonMCPConfig) {
    this.config = {
      readOnly: true,
      maxResults: 100,
      timeout: 300,
      auditLogging: false,
      ...config
    }
  }

  async connect(): Promise<void> {
    if (this.isConnected) return

    // In development mode or when using mock data, skip actual MCP connection
    if (process.env.NODE_ENV === 'development' || !this.config.apiKey || this.config.apiKey === 'mock_key') {
      this.isConnected = true
      if (this.config.auditLogging) {
      }
      return
    }

    try {
      // Spawn the Crayon MCP server process
      const serverProcess = spawn('npx', [
        '-y',
        '@crayon/mcp-server',
        '--api-key',
        this.config.apiKey,
        '--account-id',
        this.config.accountId,
        '--workspace-id',
        this.config.workspaceId
      ], {
        stdio: ['pipe', 'pipe', 'pipe']
      })

      // Create transport and client
      const transport = new StdioClientTransport({
        reader: serverProcess.stdout!,
        writer: serverProcess.stdin!
      })

      this.client = new Client({
        name: 'crayon-mcp-client',
        version: '1.0.0'
      }, {
        capabilities: {}
      })

      await this.client.connect(transport)
      this.isConnected = true

      if (this.config.auditLogging) {
      }
    } catch (error) {
      console.error('Failed to connect to Crayon MCP server:', error)
      throw error
    }
  }

  async disconnect(): Promise<void> {
    if (this.client && this.isConnected) {
      await this.client.close()
      this.isConnected = false
    }
  }

  private async executeTool(toolName: string, args: any): Promise<any> {
    if (!this.isConnected) {
      await this.connect()
    }

    // In development mode or mock mode, return mock data
    if (process.env.NODE_ENV === 'development' || !this.config.apiKey || this.config.apiKey === 'mock_key') {
      if (this.config.auditLogging) {
      }
      return [{ text: 'mock_data' }] // Return mock format
    }

    try {
      const result = await this.client.callTool({
        name: toolName,
        arguments: args
      })

      if (this.config.auditLogging) {
        console.log(`Crayon MCP tool executed: ${toolName}`, { args, result })
      }

      return result.content
    } catch (error) {
      console.error(`Crayon MCP tool execution failed: ${toolName}`, error)
      throw error
    }
  }

  // Competitive Intelligence Methods

  async getBattlecard(competitor: string, options: CrayonQueryOptions = {}): Promise<CrayonBattlecard> {
    const args = {
      competitor,
      product: options.product,
      useCase: options.useCase,
      market: options.market,
      limit: this.config.maxResults
    }

    const result = await this.executeTool('get_battlecard', args)
    
    // In mock mode, always return mock data
    if (process.env.NODE_ENV === 'development' || !this.config.apiKey || this.config.apiKey === 'mock_key') {
      return this.getMockBattlecard(competitor)
    }
    
    return result[0]?.text ? JSON.parse(result[0].text) : this.getMockBattlecard(competitor)
  }

  async getWinLossStories(options: CrayonQueryOptions = {}): Promise<CrayonWinLossStory[]> {
    const args = {
      competitor: options.competitor,
      timeRange: options.timeRange || 'last_quarter',
      outcome: options.outcome,
      limit: this.config.maxResults
    }

    const result = await this.executeTool('get_win_loss_stories', args)
    
    // In mock mode, always return mock data
    if (process.env.NODE_ENV === 'development' || !this.config.apiKey || this.config.apiKey === 'mock_key') {
      return this.getMockWinLossStories()
    }
    
    return result[0]?.text ? JSON.parse(result[0].text) : this.getMockWinLossStories()
  }

  async getCompetitorProfile(competitor: string, options: CrayonQueryOptions = {}): Promise<CrayonCompetitorProfile> {
    const args = {
      competitor,
      include: options.include || ['products', 'pricing', 'recent_news'],
      limit: this.config.maxResults
    }

    const result = await this.executeTool('get_competitor_profile', args)
    
    // In mock mode, always return mock data
    if (process.env.NODE_ENV === 'development' || !this.config.apiKey || this.config.apiKey === 'mock_key') {
      return this.getMockCompetitorProfile(competitor)
    }
    
    return result[0]?.text ? JSON.parse(result[0].text) : this.getMockCompetitorProfile(competitor)
  }

  // Sales Enablement Methods

  async getObjectionHandling(options: CrayonQueryOptions = {}): Promise<CrayonObjectionHandling[]> {
    const args = {
      competitor: options.competitor,
      objection: options.objection,
      context: options.context,
      limit: this.config.maxResults
    }

    const result = await this.executeTool('get_objection_handling', args)
    
    // In mock mode, always return mock data
    if (process.env.NODE_ENV === 'development' || !this.config.apiKey || this.config.apiKey === 'mock_key') {
      return this.getMockObjectionHandling()
    }
    
    return result[0]?.text ? JSON.parse(result[0].text) : this.getMockObjectionHandling()
  }

  async getCompetitivePositioning(options: CrayonQueryOptions = {}): Promise<any> {
    const args = {
      yourProduct: options.yourProduct,
      competitor: options.competitor,
      market: options.market,
      limit: this.config.maxResults
    }

    const result = await this.executeTool('get_competitive_positioning', args)
    
    // In mock mode, always return mock data
    if (process.env.NODE_ENV === 'development' || !this.config.apiKey || this.config.apiKey === 'mock_key') {
      return this.getMockCompetitivePositioning()
    }
    
    return result[0]?.text ? JSON.parse(result[0].text) : this.getMockCompetitivePositioning()
  }

  async getDealIntelligence(options: CrayonQueryOptions = {}): Promise<CrayonDealIntelligence> {
    const args = {
      prospect: options.prospect,
      competitors: options.competitors,
      dealStage: options.dealStage,
      limit: this.config.maxResults
    }

    const result = await this.executeTool('get_deal_intelligence', args)
    
    // In mock mode, always return mock data
    if (process.env.NODE_ENV === 'development' || !this.config.apiKey || this.config.apiKey === 'mock_key') {
      return this.getMockDealIntelligence()
    }
    
    return result[0]?.text ? JSON.parse(result[0].text) : this.getMockDealIntelligence()
  }

  // Market Intelligence Methods

  async getMarketAlerts(options: CrayonQueryOptions = {}): Promise<CrayonMarketAlert[]> {
    const args = {
      competitors: options.competitors,
      alertTypes: options.alertTypes,
      timeRange: options.timeRange || 'last_30_days',
      limit: this.config.maxResults
    }

    const result = await this.executeTool('get_market_alerts', args)
    
    // In mock mode, always return mock data
    if (process.env.NODE_ENV === 'development' || !this.config.apiKey || this.config.apiKey === 'mock_key') {
      return this.getMockMarketAlerts()
    }
    
    return result[0]?.text ? JSON.parse(result[0].text) : this.getMockMarketAlerts()
  }

  async getCompetitorNews(options: CrayonQueryOptions = {}): Promise<any[]> {
    const args = {
      competitor: options.competitor,
      timeRange: options.timeRange || 'last_week',
      categories: options.categories,
      limit: this.config.maxResults
    }

    const result = await this.executeTool('get_competitor_news', args)
    
    // In mock mode, always return mock data
    if (process.env.NODE_ENV === 'development' || !this.config.apiKey || this.config.apiKey === 'mock_key') {
      return this.getMockCompetitorNews()
    }
    
    return result[0]?.text ? JSON.parse(result[0].text) : this.getMockCompetitorNews()
  }

  async getMarketTrends(options: CrayonQueryOptions = {}): Promise<any> {
    const args = {
      market: options.market,
      timeRange: options.timeRange || 'last_quarter',
      include: options.include,
      limit: this.config.maxResults
    }

    const result = await this.executeTool('get_market_trends', args)
    
    // In mock mode, always return mock data
    if (process.env.NODE_ENV === 'development' || !this.config.apiKey || this.config.apiKey === 'mock_key') {
      return this.getMockMarketTrends()
    }
    
    return result[0]?.text ? JSON.parse(result[0].text) : this.getMockMarketTrends()
  }

  // Mock Data Methods (for development)

  private getMockBattlecard(competitor: string): CrayonBattlecard {
    return {
      competitor,
      strengths: ['Strong brand recognition', 'Enterprise focus', 'Comprehensive feature set'],
      weaknesses: ['High pricing', 'Complex implementation', 'Limited customization'],
      positioning: 'Focus on ease of use, competitive pricing, and superior customer support',
      objections: ['Pricing concerns', 'Implementation complexity', 'Feature gaps'],
      responses: [
        'Emphasize ROI and total cost of ownership',
        'Highlight implementation support and training',
        'Showcase unique features and competitive advantages'
      ],
      lastUpdated: new Date().toISOString()
    }
  }

  private getMockWinLossStories(): CrayonWinLossStory[] {
    return [
      {
        id: '1',
        competitor: 'Competitor A',
        outcome: 'won',
        dealValue: 50000,
        keyFactors: ['Better pricing', 'Superior support', 'Faster implementation'],
        lessons: ['Price competitively', 'Emphasize support quality', 'Highlight speed to value'],
        date: '2024-01-15'
      },
      {
        id: '2',
        competitor: 'Competitor B',
        outcome: 'lost',
        dealValue: 75000,
        keyFactors: ['Feature gaps', 'Integration complexity', 'Higher pricing'],
        lessons: ['Improve feature set', 'Simplify integrations', 'Review pricing strategy'],
        date: '2024-01-10'
      }
    ]
  }

  private getMockCompetitorProfile(competitor: string): CrayonCompetitorProfile {
    return {
      name: competitor,
      description: `${competitor} is a leading provider of enterprise software solutions.`,
      products: ['Product A', 'Product B', 'Product C'],
      pricing: {
        model: 'Subscription-based',
        range: '$10,000 - $100,000 annually',
        notes: 'Pricing varies based on features and user count'
      },
      recentNews: [
        'Raised $50M in Series C funding',
        'Launched new AI-powered features',
        'Expanded into European markets'
      ],
      marketPosition: 'Market leader in enterprise segment',
      lastUpdated: new Date().toISOString()
    }
  }

  private getMockObjectionHandling(): CrayonObjectionHandling[] {
    return [
      {
        objection: 'Your pricing is too high',
        competitor: 'Competitor A',
        context: 'enterprise_deal',
        response: 'Focus on ROI and total cost of ownership. Our solution provides better value over time.',
        supportingData: ['ROI calculator', 'Case studies', 'Cost comparison'],
        successRate: 0.75
      }
    ]
  }

  private getMockCompetitivePositioning(): any {
    return {
      positioning: 'Ease of use and competitive pricing',
      keyDifferentiators: ['User-friendly interface', 'Fast implementation', 'Excellent support'],
      competitiveAdvantages: ['Lower total cost', 'Faster time to value', 'Better user experience']
    }
  }

  private getMockDealIntelligence(): CrayonDealIntelligence {
    return {
      prospect: 'Example Company',
      competitors: ['Competitor A', 'Competitor B'],
      dealStage: 'proposal',
      competitiveThreats: ['Pricing pressure', 'Feature gaps'],
      opportunities: ['Strong relationship', 'Technical fit'],
      recommendations: ['Emphasize ROI', 'Address feature concerns', 'Leverage relationship'],
      lastUpdated: new Date().toISOString()
    }
  }

  private getMockMarketAlerts(): CrayonMarketAlert[] {
    return [
      {
        id: '1',
        type: 'product_launch',
        competitor: 'Competitor A',
        title: 'New AI-powered features launched',
        description: 'Competitor A has launched new AI capabilities that could impact our positioning.',
        impact: 'high',
        date: '2024-01-20'
      }
    ]
  }

  private getMockCompetitorNews(): any[] {
    return [
      {
        title: 'Competitor A raises $50M in funding',
        date: '2024-01-18',
        category: 'funding',
        summary: 'Series C funding round to expand product development'
      }
    ]
  }

  private getMockMarketTrends(): any {
    return {
      trends: ['AI integration', 'Cloud migration', 'Security focus'],
      competitorAnalysis: 'Most competitors are investing heavily in AI features',
      pricingTrends: 'Pricing pressure increasing in enterprise segment'
    }
  }
}

// Factory function to create Crayon MCP client
export function createCrayonMCPClient(config?: Partial<CrayonMCPConfig>): CrayonMCPClient {
  const defaultConfig: CrayonMCPConfig = {
    apiKey: process.env.CRAYON_API_KEY || '',
    accountId: process.env.CRAYON_ACCOUNT_ID || '',
    workspaceId: process.env.CRAYON_WORKSPACE_ID || '',
    readOnly: process.env.CRAYON_MCP_READ_ONLY === 'true',
    maxResults: parseInt(process.env.CRAYON_MCP_MAX_RESULTS || '100'),
    timeout: parseInt(process.env.CRAYON_MCP_TIMEOUT || '300'),
    auditLogging: process.env.CRAYON_MCP_AUDIT_LOGGING === 'true'
  }

  const finalConfig = { ...defaultConfig, ...config }
  return new CrayonMCPClient(finalConfig)
}

// Export types for use in other modules
export type {
  CrayonMCPConfig,
  CrayonQueryOptions,
  CrayonBattlecard,
  CrayonWinLossStory,
  CrayonCompetitorProfile,
  CrayonObjectionHandling,
  CrayonDealIntelligence,
  CrayonMarketAlert
}
